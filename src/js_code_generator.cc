#include "js_code_generator.h"

#include <algorithm>
#include <cctype>
#include <functional>
#include <memory>
#include <regex>
#include <sstream>
#include <string>
#include <utility>
#include <vector>
#include <filesystem>

#include "google/protobuf/descriptor.pb.h"
#include "type_helper.h"
#include "type_resolver.h"
#include "string_extensions.h"

namespace protoc_js_gen_plugin {
namespace {

using google::protobuf::DescriptorProto;
using google::protobuf::EnumDescriptorProto;
using google::protobuf::FieldDescriptorProto;
using google::protobuf::FileDescriptorProto;

// Helper to replace extension
std::string ChangeExtension(const std::string& path, const std::string& new_ext) {
    size_t dot_pos = path.find_last_of('.');
    if (dot_pos == std::string::npos) return path + new_ext;
    return path.substr(0, dot_pos) + new_ext;
}

// Helper to get filename without extension
std::string GetFileNameWithoutExtension(const std::string& path) {
    size_t slash_pos = path.find_last_of("/\\");
    size_t dot_pos = path.find_last_of('.');

    std::string filename = (slash_pos == std::string::npos) ?
        path : path.substr(slash_pos + 1);

    if (dot_pos != std::string::npos && dot_pos > (slash_pos == std::string::npos ? 0 : slash_pos + 1)) {
        filename = filename.substr(0, dot_pos - (slash_pos == std::string::npos ? 0 : slash_pos + 1));
    }

    return filename;
}

// Helper to compute relative path from current file to target file
std::string GetRelativePath(const std::string& from, const std::string& to) {
    // Use std::filesystem
    std::filesystem::path from_path(from);
    std::filesystem::path to_path(to);
    std::filesystem::path relative = std::filesystem::relative(to_path, from_path.parent_path());
    return relative.generic_string();
}

}  // namespace

JsCodeGenerator::JsCodeGenerator(
    const FileDescriptorProto& proto_file,
    const TypeResolver& type_resolver)
    : proto_file_(proto_file),
    type_resolver_(type_resolver) {
}

std::string JsCodeGenerator::Generate() {
    // Clear state for multiple calls
    output_.str("");
    output_.clear();
    generated_nested_classes_.clear();
    referenced_external_types_.clear();
    import_aliases_.clear();

    // Collect all external type references
    CollectExternalTypeReferences();

    // Generate file header
    output_ << "// Generated by protoc-gen-js-mjs\n";
    output_ << "// Source: " << proto_file_.name() << "\n\n";

    if (!proto_file_.package().empty()) {
        output_ << "// Package: " << proto_file_.package() << "\n\n";
    }

    // Generate import statements
    GenerateImports();

    // Set up type name transformer
    TypeHelper::TypeNameTransformer old_transformer = TypeHelper::GetTypeNameTransformer();
    TypeHelper::SetTypeNameTransformer([this](const std::string& type_name,
        const FileDescriptorProto& file) {
            return this->TransformTypeName(type_name, file);
        });

    try {
        // Generate enums
        for (const EnumDescriptorProto& enum_type : proto_file_.enum_type()) {
            GenerateEnum(enum_type);
        }

        // Generate messages
        for (const DescriptorProto& message_type : proto_file_.message_type()) {
            GenerateMessage(message_type, "", proto_file_.package());
        }
    }
    catch (...) {
        // Restore transformer on exception
        TypeHelper::SetTypeNameTransformer(old_transformer);
        throw;
    }

    // Restore transformer
    TypeHelper::SetTypeNameTransformer(old_transformer);

    return output_.str();
}

void JsCodeGenerator::CollectExternalTypeReferences() {
    // Collect type references from messages
    for (const DescriptorProto& message_type : proto_file_.message_type()) {
        CollectMessageTypeReferences(message_type);
    }
}

void JsCodeGenerator::CollectMessageTypeReferences(
    const DescriptorProto& message_type) {

    // Process fields
    for (const FieldDescriptorProto& field : message_type.field()) {
        if (field.type() == FieldDescriptorProto::TYPE_MESSAGE ||
            field.type() == FieldDescriptorProto::TYPE_ENUM) {
            RecordTypeReference(field.type_name());
        }
    }

    // Recursively process nested messages
    for (const DescriptorProto& nested_message : message_type.nested_type()) {
        CollectMessageTypeReferences(nested_message);
    }
}

void JsCodeGenerator::GenerateImports() {
    std::vector<std::string> referenced_types(
        referenced_external_types_.begin(), referenced_external_types_.end());

    auto imports = type_resolver_.GetRequiredImports(referenced_types);
    if (imports.empty()) return;

    // Group imports by proto file
    std::unordered_map<std::string, std::vector<std::string>> imports_by_file;
    for (const auto& import : imports) {
        imports_by_file[import.first].push_back(import.second);
    }

    // Remove duplicates within each file
    for (auto& entry : imports_by_file) {
        std::sort(entry.second.begin(), entry.second.end());
        entry.second.erase(std::unique(entry.second.begin(), entry.second.end()),
            entry.second.end());
    }

    // Generate import statements
    ImportAliasMap import_aliases;
    for (const auto& entry : imports_by_file) {
        const std::string& proto_file = entry.first;
        const std::vector<std::string>& type_names = entry.second;

        std::string import_path = GetImportPath(proto_file);
        std::string alias = GenerateImportAlias(proto_file);

        // Ensure alias is unique
        int counter = 1;
        std::string original_alias = alias;
        while (import_aliases.find(alias) != import_aliases.end()) {
            alias = original_alias + std::to_string(counter);
            ++counter;
        }

        import_aliases[proto_file] = alias;

        // Generate import * as statement
        output_ << "import * as " << alias << " from '" << import_path << "';\n";
    }

    output_ << "\n";
    import_aliases_ = std::move(import_aliases);
}

std::string JsCodeGenerator::GetImportPath(const std::string& proto_file_path) const {
    // Get current proto file path
    std::string current_file = proto_file_.name();
    // Compute relative path from current file's directory to target file
    std::string relative_path = GetRelativePath(current_file, proto_file_path);
    // Change .proto extension to .mjs
    std::string mjs_path = ChangeExtension(relative_path, ".mjs");
    // Ensure forward slashes (already done by generic_string)
    // Add "./" prefix if not already a relative path starting with "./" or "../"
    if (mjs_path.find("./") != 0 && mjs_path.find("../") != 0) {
        mjs_path = "./" + mjs_path;
    }
    return mjs_path;
}

std::string JsCodeGenerator::GenerateImportAlias(const std::string& proto_file_path) const {
    // Remove extension
    std::string file_name = GetFileNameWithoutExtension(proto_file_path);

    // Remove leading "./" or "../"
    std::string path = proto_file_path;
    std::replace(path.begin(), path.end(), '\\', '/');

    if (path.find("./") == 0) {
        path = path.substr(2);
    }
    else if (path.find("../") == 0) {
        path = path.substr(3);
    }

    // Remove extension
    path = ChangeExtension(path, "");

    // Split path parts
    std::vector<std::string> parts;
    std::stringstream ss(path);
    std::string part;
    while (std::getline(ss, part, '/')) {
        parts.push_back(part);
    }

    // Convert each part to PascalCase
    for (std::string& part : parts) {
        if (part.empty()) continue;

        // Remove invalid characters, keep only alphanumeric and underscore
        std::string cleaned;
        for (char c : part) {
            if (std::isalnum(static_cast<unsigned char>(c)) || c == '_') {
                cleaned += c;
            }
            else {
                cleaned += '_';
            }
        }

        if (cleaned.empty()) {
            cleaned = "Part";
        }

        // Ensure first character is uppercase
        if (!cleaned.empty() && std::islower(static_cast<unsigned char>(cleaned[0]))) {
            cleaned[0] = static_cast<char>(std::toupper(static_cast<unsigned char>(cleaned[0])));
        }

        part = cleaned;
    }

    // Combine all parts
    std::string alias;
    for (const std::string& part : parts) {
        if (!part.empty()) {
            alias += part;
        }
    }

    // Add prefix if alias is empty or starts with underscore
    if (alias.empty() || alias[0] == '_') {
        alias = "Import" + alias;
    }

    // Ensure alias starts with a letter
    if (!alias.empty() && !std::isalpha(static_cast<unsigned char>(alias[0]))) {
        alias = "Import" + alias;
    }

    return "__" + alias;
}

std::string JsCodeGenerator::TransformTypeName(
    const std::string& type_name,
    const FileDescriptorProto& proto_file) {

    // Only process if the file matches
    if (proto_file.name() != proto_file_.name()) {
        return "";
    }

    auto external_info = type_resolver_.GetExternalTypeInfo(type_name);
    if (external_info && !external_info->first.empty()) {
        auto it = import_aliases_.find(external_info->first);
        if (it != import_aliases_.end()) {
            // External type, use alias
            return it->second + "." + external_info->second;
        }
    }

    // Return empty string to let TypeHelper use default logic
    return "";
}

void JsCodeGenerator::RecordTypeReference(const std::string& type_name) {
    if (!type_name.empty()) {
        referenced_external_types_.insert(type_name);
    }
}

void JsCodeGenerator::GenerateEnum(const EnumDescriptorProto& enum_type) {
    output_ << "// Enum: " << enum_type.name() << "\n";
    output_ << "export const " << enum_type.name() << " = {\n";

    for (const auto& value : enum_type.value()) {
        std::string value_name = StripEnumValuePrefix(enum_type.name(), value.name());
        output_ << "    " << value_name << ": " << value.number() << ",\n";
    }

    output_ << "};\n";
    output_ << "Object.freeze(" << enum_type.name() << ");\n\n";
}

void JsCodeGenerator::GenerateMessage(
    const DescriptorProto& message_type,
    const std::string& indent,
    const std::string& parent_full_name) {

    std::string class_name = message_type.name();
    std::string full_name = parent_full_name.empty() ?
        class_name : parent_full_name + "." + class_name;
    bool is_top_level = indent.empty();

    if (!is_top_level) {
        // Nested messages shouldn't be generated by this method
        return;
    }

    // First generate independent class definitions for all nested messages
    std::unordered_map<const DescriptorProto*, std::string> nested_independent_class_names;
    for (const DescriptorProto& nested_message : message_type.nested_type()) {
        std::string independent_class_name = GenerateNestedMessageClass(nested_message, full_name);
        nested_independent_class_names[&nested_message] = independent_class_name;
    }

    // Generate top-level export class
    output_ << indent << "// Message: " << class_name << "\n";
    output_ << indent << "export class " << class_name << " {\n";

    // Static descriptor
    output_ << indent << "    static __descriptor = {\n";
    output_ << indent << "        name: \"" << class_name << "\",\n";
    output_ << indent << "        get clrType() { return " << class_name << "; },\n";
    output_ << indent << "        fullName: \"" << full_name << "\",\n";
    if (!parent_full_name.empty()) {
        output_ << indent << "        package: \"" << parent_full_name << "\",\n";
    }

    // Field descriptors
    output_ << indent << "        fields: [";
    if (message_type.field_size() > 0) {
        output_ << "\n";
        for (int i = 0; i < message_type.field_size(); ++i) {
            const FieldDescriptorProto& field = message_type.field(i);
            std::string camel_case_name = SnakeToCamelCase(field.name());
            output_ << indent << "            {";
            output_ << "name: \"" << camel_case_name << "\", ";
            output_ << "number: " << field.number() << ", ";
            output_ << "type: \"" << FieldDescriptorProto::Type_Name(field.type()) << "\", ";
            if (!field.type_name().empty()) {
                output_ << "typeName: \"" << field.type_name() << "\", ";
            }
            // Add clrType field for message and enum types
            std::string class_ref = GetFieldClassRef(field);
            if (!class_ref.empty()) {
                output_ << "get clrType() { return " << class_ref << "; },";
            }
            output_ << "label: \"" << FieldDescriptorProto::Label_Name(field.label()) << "\"}";
            if (i < message_type.field_size() - 1) {
                output_ << ",\n";
            }
            else {
                output_ << "\n";
            }
        }
        output_ << indent << "        ]";
    }
    else {
        output_ << "]";
    }
    output_ << "\n";
    output_ << indent << "    }\n\n";

    // Generate getter/setter methods for fields
    for (const FieldDescriptorProto& field : message_type.field()) {
        GenerateFieldMethods(field, indent + "    ", class_name);
    }

    // Add static references to nested messages
    for (const DescriptorProto& nested_message : message_type.nested_type()) {
        auto it = nested_independent_class_names.find(&nested_message);
        if (it != nested_independent_class_names.end()) {
            output_ << indent << "    static " << nested_message.name()
                << " = " << it->second << ";\n";
        }
    }

    // Generate nested enums
    for (const EnumDescriptorProto& nested_enum : message_type.enum_type()) {
        output_ << "\n";
        GenerateNestedEnum(nested_enum, indent + "    ");
    }

    output_ << indent << "}\n\n";
}

std::string JsCodeGenerator::GenerateNestedMessageClass(
    const DescriptorProto& message_type,
    const std::string& parent_full_name) {

    std::string class_name = message_type.name();
    std::string full_name = parent_full_name.empty() ?
        class_name : parent_full_name + "." + class_name;

    // Check if already generated
    if (generated_nested_classes_.find(full_name) != generated_nested_classes_.end()) {
        return TypeHelper::GetIndependentClassName(full_name, &proto_file_);
    }

    generated_nested_classes_.insert(full_name);

    // Generate independent class definition
    std::string independent_class_name = TypeHelper::GetIndependentClassName(full_name, &proto_file_);
    output_ << "class " << independent_class_name << " {\n";

    // Static descriptor
    output_ << "    static __descriptor = {\n";
    output_ << "        name: \"" << class_name << "\",\n";
    output_ << "        get clrType() { return " << independent_class_name << "; },\n";
    output_ << "        fullName: \"" << full_name << "\",\n";

    // Field descriptors
    output_ << "        fields: [";
    if (message_type.field_size() > 0) {
        output_ << "\n";
        for (int i = 0; i < message_type.field_size(); ++i) {
            const FieldDescriptorProto& field = message_type.field(i);
            std::string camel_case_name = SnakeToCamelCase(field.name());
            output_ << "            {";
            output_ << "name: \"" << camel_case_name << "\", ";
            output_ << "number: " << field.number() << ", ";
            output_ << "type: \"" << FieldDescriptorProto::Type_Name(field.type()) << "\", ";
            if (!field.type_name().empty()) {
                output_ << "typeName: \"" << field.type_name() << "\", ";
            }
            // Add clrType field for message and enum types
            std::string class_ref = GetFieldClassRef(field);
            if (!class_ref.empty()) {
                output_ << "get clrType() { return " << class_ref << "; },";
            }
            output_ << "label: \"" << FieldDescriptorProto::Label_Name(field.label()) << "\"}";
            if (i < message_type.field_size() - 1) {
                output_ << ",\n";
            }
            else {
                output_ << "\n";
            }
        }
        output_ << "        ]";
    }
    else {
        output_ << "]";
    }
    output_ << "\n";
    output_ << "    }\n\n";

    // Generate getter/setter methods for fields
    for (const FieldDescriptorProto& field : message_type.field()) {
        GenerateFieldMethods(field, "    ", independent_class_name);
    }

    // Recursively generate independent class definitions for nested messages
    for (const DescriptorProto& nested_message : message_type.nested_type()) {
        std::string nested_independent_class_name =
            GenerateNestedMessageClass(nested_message, full_name);
        // Add static reference in current class
        output_ << "    static " << nested_message.name()
            << " = " << nested_independent_class_name << ";\n";
    }

    // Generate nested enums
    for (const EnumDescriptorProto& nested_enum : message_type.enum_type()) {
        output_ << "\n";
        GenerateNestedEnum(nested_enum, "    ");
    }

    output_ << "}\n\n";

    return independent_class_name;
}

void JsCodeGenerator::GenerateNestedEnum(
    const EnumDescriptorProto& enum_type,
    const std::string& indent) {

    output_ << indent << "// Nested enum: " << enum_type.name() << "\n";
    output_ << indent << "static " << enum_type.name() << " = {\n";

    for (const auto& value : enum_type.value()) {
        std::string value_name = StripEnumValuePrefix(enum_type.name(), value.name());
        output_ << indent << "    " << value_name << ": " << value.number() << ",\n";
    }

    output_ << indent << "};\n";
    output_ << indent << "Object.freeze(" << enum_type.name() << ");\n";
}

void JsCodeGenerator::GenerateFieldMethods(
    const FieldDescriptorProto& field,
    const std::string& indent,
    const std::string& class_name) {

    std::string field_name = field.name();
    std::string camel_case_name = SnakeToCamelCase(field_name);
    std::string pascal_case_name = SnakeToPascalCase(field_name);

    // Check if it's a oneof field
    bool is_oneof_field = field.has_oneof_index() && field.oneof_index() >= 0;

    if (is_oneof_field) {
        output_ << indent << "// Oneof field (index: " << field.oneof_index() << ")\n";
    }

    // Record external type reference
    if (field.type() == FieldDescriptorProto::TYPE_MESSAGE ||
        field.type() == FieldDescriptorProto::TYPE_ENUM) {
        RecordTypeReference(field.type_name());
    }

    // Field type mapping
    std::string js_type = TypeHelper::GetJsType(field, proto_file_);

    // Getter method
    output_ << indent << "/** \n";
    output_ << indent << " * @return {" << js_type << "} \n";
    output_ << indent << " */\n";
    output_ << indent << "get" << TypeHelper::GetMethodName(field) << "() {\n";
    output_ << indent << "    return this." << camel_case_name << ";\n";
    output_ << indent << "}\n\n";

    // Setter method (supports fluent chaining)
    output_ << indent << "/** \n";
    output_ << indent << " * @param {" << js_type << "} value \n";
    output_ << indent << " * @return {" << class_name << "} \n";
    output_ << indent << " */\n";
    output_ << indent << "set" << TypeHelper::GetMethodName(field) << "(value) {\n";
    output_ << indent << "    this." << camel_case_name << " = value;\n";
    output_ << indent << "    return this;\n";
    output_ << indent << "}\n\n";
}

std::string JsCodeGenerator::GetFieldClassRef(
    const google::protobuf::FieldDescriptorProto& field) {

    using google::protobuf::FieldDescriptorProto;

    // Only message and enum types need class references
    if (field.type() != FieldDescriptorProto::TYPE_MESSAGE &&
        field.type() != FieldDescriptorProto::TYPE_ENUM) {
        return "";
    }

    // Use the type name transformer to get the JavaScript reference
    if (TypeHelper::GetTypeNameTransformer()) {
        std::string transformed = TypeHelper::GetTypeNameTransformer()(field.type_name(), proto_file_);
        if (!transformed.empty()) {
            return transformed;
        }
    }

    // For local types, get the appropriate class name
    if (field.type() == FieldDescriptorProto::TYPE_MESSAGE) {
        return TypeHelper::GetMessageTypeName(field.type_name(), proto_file_);
    } else if (field.type() == FieldDescriptorProto::TYPE_ENUM) {
        // For enums, return the last component (enum name)
        // Remove leading dot if present
        std::string type_name = field.type_name();
        if (!type_name.empty() && type_name[0] == '.') {
            type_name = type_name.substr(1);
        }
        size_t pos = type_name.find_last_of('.');
        if (pos != std::string::npos) {
            return type_name.substr(pos + 1);
        }
        return type_name;
    }

    return "";
}
}