using Google.Protobuf;
using Google.Protobuf.Compiler;
using Google.Protobuf.Reflection;
using System.Text;
using System.IO;
using System.Linq;

namespace ProtocJsGenPlugin;

class Program
{
    static void Main(string[] args)
    {
        // 从stdin读取整个请求数据
        using var stdin = Console.OpenStandardInput();
        using var stdout = Console.OpenStandardOutput();

        // 读取请求
        var request = CodeGeneratorRequest.Parser.ParseFrom(stdin);

        // 处理请求并生成响应
        var response = ProcessRequest(request);

        // 写入响应到stdout
        response.WriteTo(stdout);
    }

    static CodeGeneratorResponse ProcessRequest(CodeGeneratorRequest request)
    {
        var response = new CodeGeneratorResponse();

        foreach (var protoFile in request.ProtoFile)
        {
            // 只处理用户请求的文件，而不是所有依赖
            if (!request.FileToGenerate.Contains(protoFile.Name))
                continue;

            var fileContent = GenerateFileContent(protoFile);

            response.File.Add(new CodeGeneratorResponse.Types.File
            {
                Name = GetOutputFileName(protoFile.Name),
                Content = fileContent
            });
        }

        return response;
    }

    static string GetOutputFileName(string protoFileName)
    {
        // 将.proto扩展名替换为.mjs
        return Path.ChangeExtension(protoFileName, ".mjs");
    }

    static string GenerateFileContent(FileDescriptorProto protoFile)
    {
        var generator = new JsCodeGenerator(protoFile);
        return generator.Generate();
    }
}

internal static class StringExtensions
{
    /// <summary>
    /// 将snake_case转换为camelCase
    /// </summary>
    public static string SnakeToCamelCase(this string snakeCase)
    {
        if (string.IsNullOrEmpty(snakeCase))
            return snakeCase;

        var parts = snakeCase.Split('_');
        var result = new StringBuilder();

        for (int i = 0; i < parts.Length; i++)
        {
            var part = parts[i];
            if (string.IsNullOrEmpty(part))
                continue;

            if (i == 0)
            {
                // 第一个单词保持小写
                result.Append(part);
            }
            else
            {
                // 后续单词首字母大写
                result.Append(char.ToUpperInvariant(part[0]));
                if (part.Length > 1)
                    result.Append(part.Substring(1));
            }
        }

        return result.ToString();
    }

    /// <summary>
    /// 将snake_case转换为PascalCase
    /// </summary>
    public static string SnakeToPascalCase(this string snakeCase)
    {
        if (string.IsNullOrEmpty(snakeCase))
            return snakeCase;

        var parts = snakeCase.Split('_');
        var result = new StringBuilder();

        foreach (var part in parts)
        {
            if (string.IsNullOrEmpty(part))
                continue;

            result.Append(char.ToUpperInvariant(part[0]));
            if (part.Length > 1)
                result.Append(part.Substring(1));
        }

        return result.ToString();
    }
}

internal class JsCodeGenerator
{
    private readonly FileDescriptorProto _protoFile;
    private readonly StringBuilder _sb = new StringBuilder();

    public JsCodeGenerator(FileDescriptorProto protoFile)
    {
        _protoFile = protoFile;
    }

    public string Generate()
    {
        _sb.AppendLine("// Generated by protoc-gen-js-mjs");
        _sb.AppendLine($"// Source: {_protoFile.Name}");
        _sb.AppendLine();

        if (!string.IsNullOrEmpty(_protoFile.Package))
        {
            _sb.AppendLine($"// Package: {_protoFile.Package}");
            _sb.AppendLine();
        }

        // 生成枚举
        foreach (var enumType in _protoFile.EnumType)
        {
            GenerateEnum(enumType);
        }

        // 生成消息
        foreach (var messageType in _protoFile.MessageType)
        {
            GenerateMessage(messageType, "", _protoFile.Package ?? "");
        }

        return _sb.ToString();
    }

    private void GenerateEnum(EnumDescriptorProto enumType)
    {
        _sb.AppendLine($"// Enum: {enumType.Name}");
        _sb.AppendLine($"export const {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"    {value.Name}: {value.Number},");
        }

        _sb.AppendLine("};");
        _sb.AppendLine();
    }

    private void GenerateMessage(DescriptorProto messageType, string indent, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";
        var isTopLevel = string.IsNullOrEmpty(indent);

        if (isTopLevel)
        {
            _sb.AppendLine($"{indent}// Message: {className}");
            _sb.AppendLine($"{indent}export class {className} {{");
        }
        else
        {
            _sb.AppendLine($"{indent}// Nested message: {className}");
            _sb.AppendLine($"{indent}static {className} = class {{");
        }

        // 静态描述符
        _sb.AppendLine($"{indent}    static __descriptor = {{");
        _sb.AppendLine($"{indent}        name: \"{className}\",");
        _sb.AppendLine($"{indent}        fullName: \"{fullName}\",");
        _sb.AppendLine($"{indent}    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, indent + "    ");
        }

        // 生成嵌套消息
        foreach (var nestedMessage in messageType.NestedType)
        {
            _sb.AppendLine();
            GenerateMessage(nestedMessage, indent + "    ", fullName);
        }

        // 生成嵌套枚举
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, indent + "    ");
        }

        if (isTopLevel)
        {
            _sb.AppendLine($"{indent}}}");
        }
        else
        {
            _sb.AppendLine($"{indent}}};");
        }

        _sb.AppendLine();
    }

    private void GenerateNestedEnum(EnumDescriptorProto enumType, string indent)
    {
        _sb.AppendLine($"{indent}// Nested enum: {enumType.Name}");
        _sb.AppendLine($"{indent}static {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"{indent}    {value.Name}: {value.Number},");
        }

        _sb.AppendLine($"{indent}}};");
    }

    private void GenerateFieldMethods(FieldDescriptorProto field, string indent)
    {
        var fieldName = field.Name;
        var camelCaseName = fieldName.SnakeToCamelCase();
        var pascalCaseName = fieldName.SnakeToPascalCase();

        // 检查是否是oneof字段
        bool isOneofField = field.HasOneofIndex && field.OneofIndex >= 0;

        if (isOneofField)
        {
            _sb.AppendLine($"{indent}// Oneof field (index: {field.OneofIndex})");
        }

        // 字段类型映射
        var jsType = GetJsType(field);

        // Getter方法
        _sb.AppendLine($"{indent}/** @return {{{jsType}}} */");
        _sb.AppendLine($"{indent}get{GetMethodName(field)}() {{");
        _sb.AppendLine($"{indent}    return this.{fieldName};");
        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();

        // Setter方法
        _sb.AppendLine($"{indent}/** @param {{{jsType}}} value */");
        _sb.AppendLine($"{indent}set{GetMethodName(field)}(value) {{");
        _sb.AppendLine($"{indent}    this.{fieldName} = value;");
        _sb.AppendLine($"{indent}}}");

        // 如果不是最后一个字段，添加空行
        _sb.AppendLine();
    }


    private string GetMethodName(FieldDescriptorProto field)
    {
        return field.Name.SnakeToPascalCase();
    }

    private string GetJsType(FieldDescriptorProto field)
    {
        var baseType = GetBaseJsType(field);

        // 处理repeated字段（数组）
        if (field.Label == FieldDescriptorProto.Types.Label.Repeated)
        {
            // 检查是否是map（proto中的map会被表示为repeated的特定消息类型）
            if (IsMapField(field))
            {
                var mapTypes = GetMapKeyValueTypes(field);
                return $"Map<{mapTypes.keyType}, {mapTypes.valueType}>";
            }
            else
            {
                return $"{baseType}[]";
            }
        }

        // 处理optional字段（proto3中所有字段都是可选的，但我们可以标记为可能为null）
        // 对于标量类型，在JS中可以是undefined
        return baseType;
    }

    private string GetBaseJsType(FieldDescriptorProto field)
    {
        switch (field.Type)
        {
            case FieldDescriptorProto.Types.Type.Double:
            case FieldDescriptorProto.Types.Type.Float:
                return "number";

            case FieldDescriptorProto.Types.Type.Int64:
            case FieldDescriptorProto.Types.Type.Uint64:
            case FieldDescriptorProto.Types.Type.Int32:
            case FieldDescriptorProto.Types.Type.Fixed64:
            case FieldDescriptorProto.Types.Type.Fixed32:
            case FieldDescriptorProto.Types.Type.Uint32:
            case FieldDescriptorProto.Types.Type.Sfixed32:
            case FieldDescriptorProto.Types.Type.Sfixed64:
            case FieldDescriptorProto.Types.Type.Sint32:
            case FieldDescriptorProto.Types.Type.Sint64:
                return "number";

            case FieldDescriptorProto.Types.Type.Bool:
                return "boolean";

            case FieldDescriptorProto.Types.Type.String:
                return "string";

            case FieldDescriptorProto.Types.Type.Bytes:
                return "Uint8Array";

            case FieldDescriptorProto.Types.Type.Enum:
                return field.TypeName.Split('.').Last();

            case FieldDescriptorProto.Types.Type.Message:
                return GetMessageTypeName(field.TypeName);

            default:
                return "any";
        }
    }

    private bool IsMapField(FieldDescriptorProto field)
    {
        // 简单判断：如果是repeated消息类型，并且类型名包含"Entry"，可能是map
        // 更准确的实现需要检查消息是否有key和value字段
        return field.Type == FieldDescriptorProto.Types.Type.Message &&
               field.Label == FieldDescriptorProto.Types.Label.Repeated &&
               field.TypeName?.Contains("Entry") == true;
    }

    private (string keyType, string valueType) GetMapKeyValueTypes(FieldDescriptorProto field)
    {
        // 简化实现：返回通用的类型
        // 实际应该解析消息结构获取key和value类型
        return ("string", "any");
    }

    private string GetMessageTypeName(string typeName)
    {
        // 移除开头的"."，因为proto类型名以"."开头表示绝对路径
        if (typeName.StartsWith("."))
            typeName = typeName.Substring(1);

        // 返回类型名（简化处理，实际可能需要处理嵌套）
        return typeName.Split('.').Last();
    }
}