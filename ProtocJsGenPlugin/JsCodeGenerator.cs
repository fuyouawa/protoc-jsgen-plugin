using Google.Protobuf.Reflection;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace ProtocJsGenPlugin;

internal class JsCodeGenerator
{
    private readonly FileDescriptorProto _protoFile;
    private readonly StringBuilder _sb = new StringBuilder();
    private readonly Dictionary<string, string> _nestedClassNames = new Dictionary<string, string>();
    private readonly HashSet<string> _generatedNestedClasses = new HashSet<string>();

    public JsCodeGenerator(FileDescriptorProto protoFile)
    {
        _protoFile = protoFile;
    }

    public string Generate()
    {
        _sb.AppendLine("// Generated by protoc-gen-js-mjs");
        _sb.AppendLine($"// Source: {_protoFile.Name}");
        _sb.AppendLine();

        if (!string.IsNullOrEmpty(_protoFile.Package))
        {
            _sb.AppendLine($"// Package: {_protoFile.Package}");
            _sb.AppendLine();
        }

        // 生成枚举
        foreach (var enumType in _protoFile.EnumType)
        {
            GenerateEnum(enumType);
        }

        // 生成消息
        foreach (var messageType in _protoFile.MessageType)
        {
            GenerateMessage(messageType, "", _protoFile.Package ?? "");
        }

        return _sb.ToString();
    }

    private void GenerateEnum(EnumDescriptorProto enumType)
    {
        _sb.AppendLine($"// Enum: {enumType.Name}");
        _sb.AppendLine($"export const {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"    {value.Name}: {value.Number},");
        }

        _sb.AppendLine("};");
        _sb.AppendLine();
    }

    private void GenerateMessage(DescriptorProto messageType, string indent, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";
        var isTopLevel = string.IsNullOrEmpty(indent);

        if (!isTopLevel)
        {
            // 嵌套消息不应该通过这个方法生成
            return;
        }

        // 首先为所有嵌套消息生成独立类定义
        Dictionary<DescriptorProto, string> nestedIndependentClassNames = new Dictionary<DescriptorProto, string>();
        foreach (var nestedMessage in messageType.NestedType)
        {
            string independentClassName = GenerateNestedMessageClass(nestedMessage, fullName);
            nestedIndependentClassNames[nestedMessage] = independentClassName;
        }

        // 生成顶级导出类
        _sb.AppendLine($"{indent}// Message: {className}");
        _sb.AppendLine($"{indent}export class {className} {{");

        // 静态描述符
        _sb.AppendLine($"{indent}    static __descriptor = {{");
        _sb.AppendLine($"{indent}        name: \"{className}\",");
        _sb.AppendLine($"{indent}        fullName: \"{fullName}\",");
        _sb.AppendLine($"{indent}    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, indent + "    ");
        }

        // 添加嵌套消息的静态引用
        foreach (var nestedMessage in messageType.NestedType)
        {
            string independentClassName = nestedIndependentClassNames[nestedMessage];
            _sb.AppendLine($"{indent}    static {nestedMessage.Name} = {independentClassName};");
        }

        // 生成嵌套枚举
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, indent + "    ");
        }

        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();
    }

    private string GenerateNestedMessageClass(DescriptorProto messageType, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";

        // 如果已经生成，则返回独立类名
        if (_generatedNestedClasses.Contains(fullName))
        {
            return TypeHelper.GetIndependentClassName(fullName, _protoFile);
        }

        _generatedNestedClasses.Add(fullName);

        // 生成独立类定义
        string independentClassName = TypeHelper.GetIndependentClassName(fullName, _protoFile);
        _sb.AppendLine($"class {independentClassName} {{");

        // 静态描述符
        _sb.AppendLine($"    static __descriptor = {{");
        _sb.AppendLine($"        name: \"{className}\",");
        _sb.AppendLine($"        fullName: \"{fullName}\",");
        _sb.AppendLine($"    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, "    ");
        }

        // 递归生成嵌套消息的独立类定义，并在当前类中添加静态引用
        foreach (var nestedMessage in messageType.NestedType)
        {
            string nestedIndependentClassName = GenerateNestedMessageClass(nestedMessage, fullName);
            // 在当前类中添加静态引用
            _sb.AppendLine($"    static {nestedMessage.Name} = {nestedIndependentClassName};");
        }

        // 生成嵌套枚举（保持不变）
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, "    ");
        }

        _sb.AppendLine($"}}");
        _sb.AppendLine();

        return independentClassName;
    }

    private void GenerateNestedEnum(EnumDescriptorProto enumType, string indent)
    {
        _sb.AppendLine($"{indent}// Nested enum: {enumType.Name}");
        _sb.AppendLine($"{indent}static {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"{indent}    {value.Name}: {value.Number},");
        }

        _sb.AppendLine($"{indent}}};");
    }

    private void GenerateFieldMethods(FieldDescriptorProto field, string indent)
    {
        var fieldName = field.Name;
        var camelCaseName = fieldName.SnakeToCamelCase();
        var pascalCaseName = fieldName.SnakeToPascalCase();

        // 检查是否是oneof字段
        bool isOneofField = field.HasOneofIndex && field.OneofIndex >= 0;

        if (isOneofField)
        {
            _sb.AppendLine($"{indent}// Oneof field (index: {field.OneofIndex})");
        }

        // 字段类型映射
        var jsType = TypeHelper.GetJsType(field, _protoFile);

        // Getter方法
        _sb.AppendLine($"{indent}/** @return {{{jsType}}} */");
        _sb.AppendLine($"{indent}get{TypeHelper.GetMethodName(field)}() {{");
        _sb.AppendLine($"{indent}    return this.{fieldName};");
        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();

        // Setter方法
        _sb.AppendLine($"{indent}/** @param {{{jsType}}} value */");
        _sb.AppendLine($"{indent}set{TypeHelper.GetMethodName(field)}(value) {{");
        _sb.AppendLine($"{indent}    this.{fieldName} = value;");
        _sb.AppendLine($"{indent}}}");

        // 如果不是最后一个字段，添加空行
        _sb.AppendLine();
    }
}