using Google.Protobuf.Reflection;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace ProtocJsGenPlugin;

internal class JsCodeGenerator
{
    private readonly FileDescriptorProto _protoFile;
    private readonly TypeResolver _typeResolver;
    private StringBuilder _sb = new StringBuilder();
    private readonly Dictionary<string, string> _nestedClassNames = new Dictionary<string, string>();
    private readonly HashSet<string> _generatedNestedClasses = new HashSet<string>();
    private readonly HashSet<string> _referencedExternalTypes = new HashSet<string>();

    public JsCodeGenerator(FileDescriptorProto protoFile, TypeResolver typeResolver)
    {
        _protoFile = protoFile;
        _typeResolver = typeResolver;
    }

    public string Generate()
    {
        // 清空StringBuilder，确保多次调用不会重复内容
        _sb.Clear();
        _referencedExternalTypes.Clear();

        // 先生成主体内容以收集所有类型引用
        var bodyBuilder = new StringBuilder();

        // 临时替换_sb以收集类型引用和生成主体内容
        var originalSb = _sb;
        try
        {
            _sb = bodyBuilder;

            // 生成枚举
            foreach (var enumType in _protoFile.EnumType)
            {
                GenerateEnum(enumType);
            }

            // 生成消息
            foreach (var messageType in _protoFile.MessageType)
            {
                GenerateMessage(messageType, "", _protoFile.Package ?? "");
            }
        }
        finally
        {
            _sb = originalSb;
        }

        // 现在生成完整的文件，包括头部和import语句
        _sb.AppendLine("// Generated by protoc-gen-js-mjs");
        _sb.AppendLine($"// Source: {_protoFile.Name}");
        _sb.AppendLine();

        if (!string.IsNullOrEmpty(_protoFile.Package))
        {
            _sb.AppendLine($"// Package: {_protoFile.Package}");
            _sb.AppendLine();
        }

        // 生成import语句
        GenerateImports();

        // 添加主体内容
        _sb.Append(bodyBuilder.ToString());

        return _sb.ToString();
    }

    private void GenerateImports()
    {
        var imports = _typeResolver.GetRequiredImports(_referencedExternalTypes);
        if (imports.Count == 0)
            return;

        // 按proto文件分组，每个文件导入多个类型
        var importsByFile = imports.GroupBy(x => x.protoFile)
                                   .ToDictionary(g => g.Key, g => g.Select(x => x.simpleName).Distinct().ToList());

        foreach (var (protoFile, typeNames) in importsByFile)
        {
            // 计算导入路径：将.proto扩展名替换为.mjs，并确保相对路径正确
            string importPath = GetImportPath(protoFile);
            string importStatement = $"import {{ {string.Join(", ", typeNames)} }} from '{importPath}';";
            _sb.AppendLine(importStatement);
        }

        _sb.AppendLine();
    }

    private string GetImportPath(string protoFilePath)
    {
        // 将.proto扩展名替换为.mjs
        string mjsPath = System.IO.Path.ChangeExtension(protoFilePath, ".mjs");

        // 确保使用正斜杠
        mjsPath = mjsPath.Replace('\\', '/');

        // 添加"./"前缀，除非已经是相对路径
        if (!mjsPath.StartsWith("./") && !mjsPath.StartsWith("../"))
        {
            mjsPath = "./" + mjsPath;
        }

        return mjsPath;
    }

    private void RecordTypeReference(string typeName)
    {
        if (!string.IsNullOrEmpty(typeName))
        {
            _referencedExternalTypes.Add(typeName);
        }
    }

    private void GenerateEnum(EnumDescriptorProto enumType)
    {
        _sb.AppendLine($"// Enum: {enumType.Name}");
        _sb.AppendLine($"export const {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"    {value.Name}: {value.Number},");
        }

        _sb.AppendLine("};");
        _sb.AppendLine();
    }

    private void GenerateMessage(DescriptorProto messageType, string indent, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";
        var isTopLevel = string.IsNullOrEmpty(indent);

        if (!isTopLevel)
        {
            // 嵌套消息不应该通过这个方法生成
            return;
        }

        // 首先为所有嵌套消息生成独立类定义
        Dictionary<DescriptorProto, string> nestedIndependentClassNames = new Dictionary<DescriptorProto, string>();
        foreach (var nestedMessage in messageType.NestedType)
        {
            string independentClassName = GenerateNestedMessageClass(nestedMessage, fullName);
            nestedIndependentClassNames[nestedMessage] = independentClassName;
        }

        // 生成顶级导出类
        _sb.AppendLine($"{indent}// Message: {className}");
        _sb.AppendLine($"{indent}export class {className} {{");

        // 静态描述符
        _sb.AppendLine($"{indent}    static __descriptor = {{");
        _sb.AppendLine($"{indent}        name: \"{className}\",");
        _sb.AppendLine($"{indent}        fullName: \"{fullName}\",");
        _sb.AppendLine($"{indent}    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, indent + "    ");
        }

        // 添加嵌套消息的静态引用
        foreach (var nestedMessage in messageType.NestedType)
        {
            string independentClassName = nestedIndependentClassNames[nestedMessage];
            _sb.AppendLine($"{indent}    static {nestedMessage.Name} = {independentClassName};");
        }

        // 生成嵌套枚举
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, indent + "    ");
        }

        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();
    }

    private string GenerateNestedMessageClass(DescriptorProto messageType, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";

        // 如果已经生成，则返回独立类名
        if (_generatedNestedClasses.Contains(fullName))
        {
            return TypeHelper.GetIndependentClassName(fullName, _protoFile);
        }

        _generatedNestedClasses.Add(fullName);

        // 生成独立类定义
        string independentClassName = TypeHelper.GetIndependentClassName(fullName, _protoFile);
        _sb.AppendLine($"class {independentClassName} {{");

        // 静态描述符
        _sb.AppendLine($"    static __descriptor = {{");
        _sb.AppendLine($"        name: \"{className}\",");
        _sb.AppendLine($"        fullName: \"{fullName}\",");
        _sb.AppendLine($"    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, "    ");
        }

        // 递归生成嵌套消息的独立类定义，并在当前类中添加静态引用
        foreach (var nestedMessage in messageType.NestedType)
        {
            string nestedIndependentClassName = GenerateNestedMessageClass(nestedMessage, fullName);
            // 在当前类中添加静态引用
            _sb.AppendLine($"    static {nestedMessage.Name} = {nestedIndependentClassName};");
        }

        // 生成嵌套枚举（保持不变）
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, "    ");
        }

        _sb.AppendLine($"}}");
        _sb.AppendLine();

        return independentClassName;
    }

    private void GenerateNestedEnum(EnumDescriptorProto enumType, string indent)
    {
        _sb.AppendLine($"{indent}// Nested enum: {enumType.Name}");
        _sb.AppendLine($"{indent}static {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"{indent}    {value.Name}: {value.Number},");
        }

        _sb.AppendLine($"{indent}}};");
    }

    private void GenerateFieldMethods(FieldDescriptorProto field, string indent)
    {
        var fieldName = field.Name;
        var camelCaseName = fieldName.SnakeToCamelCase();
        var pascalCaseName = fieldName.SnakeToPascalCase();

        // 检查是否是oneof字段
        bool isOneofField = field.HasOneofIndex && field.OneofIndex >= 0;

        if (isOneofField)
        {
            _sb.AppendLine($"{indent}// Oneof field (index: {field.OneofIndex})");
        }

        // 记录外部类型引用
        if (field.Type == FieldDescriptorProto.Types.Type.Message ||
            field.Type == FieldDescriptorProto.Types.Type.Enum)
        {
            RecordTypeReference(field.TypeName);
        }

        // 字段类型映射
        var jsType = TypeHelper.GetJsType(field, _protoFile);

        // Getter方法
        _sb.AppendLine($"{indent}/** @return {{{jsType}}} */");
        _sb.AppendLine($"{indent}get{TypeHelper.GetMethodName(field)}() {{");
        _sb.AppendLine($"{indent}    return this.{fieldName};");
        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();

        // Setter方法
        _sb.AppendLine($"{indent}/** @param {{{jsType}}} value */");
        _sb.AppendLine($"{indent}set{TypeHelper.GetMethodName(field)}(value) {{");
        _sb.AppendLine($"{indent}    this.{fieldName} = value;");
        _sb.AppendLine($"{indent}}}");

        // 如果不是最后一个字段，添加空行
        _sb.AppendLine();
    }
}