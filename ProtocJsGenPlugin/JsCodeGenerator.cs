using Google.Protobuf.Reflection;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace ProtocJsGenPlugin;

internal class JsCodeGenerator
{
    private readonly FileDescriptorProto _protoFile;
    private readonly TypeResolver _typeResolver;
    private StringBuilder _sb = new StringBuilder();
    private readonly HashSet<string> _generatedNestedClasses = new HashSet<string>();
    private readonly HashSet<string> _referencedExternalTypes = new HashSet<string>();
    private Dictionary<string, string> _importAliases;

    public JsCodeGenerator(FileDescriptorProto protoFile, TypeResolver typeResolver)
    {
        _protoFile = protoFile;
        _typeResolver = typeResolver;
        _importAliases = new Dictionary<string, string>();
    }

    public string Generate()
    {
        // 清空StringBuilder，确保多次调用不会重复内容
        _sb.Clear();
        _referencedExternalTypes.Clear();
        _importAliases.Clear();

        // 收集所有外部类型引用
        CollectExternalTypeReferences();

        // 生成文件头部
        _sb.AppendLine("// Generated by protoc-gen-js-mjs");
        _sb.AppendLine($"// Source: {_protoFile.Name}");
        _sb.AppendLine();

        if (!string.IsNullOrEmpty(_protoFile.Package))
        {
            _sb.AppendLine($"// Package: {_protoFile.Package}");
            _sb.AppendLine();
        }

        // 生成import语句（同时填充_importAliases）
        GenerateImports();

        // 设置类型名转换器
        TypeHelper.TypeNameTransformer = TransformTypeName;

        try
        {
            // 生成枚举
            foreach (var enumType in _protoFile.EnumType)
            {
                GenerateEnum(enumType);
            }

            // 生成消息
            foreach (var messageType in _protoFile.MessageType)
            {
                GenerateMessage(messageType, "", _protoFile.Package ?? "");
            }
        }
        finally
        {
            // 清除转换器
            TypeHelper.TypeNameTransformer = null;
        }

        return _sb.ToString();
    }

    private void CollectExternalTypeReferences()
    {
        // 收集枚举中的类型引用（枚举通常不引用外部类型）
        // 收集消息中的类型引用
        foreach (var messageType in _protoFile.MessageType)
        {
            CollectMessageTypeReferences(messageType);
        }
    }

    private void CollectMessageTypeReferences(DescriptorProto messageType)
    {
        // 处理字段
        foreach (var field in messageType.Field)
        {
            if (field.Type == FieldDescriptorProto.Types.Type.Message ||
                field.Type == FieldDescriptorProto.Types.Type.Enum)
            {
                RecordTypeReference(field.TypeName);
            }
        }

        // 递归处理嵌套消息
        foreach (var nestedMessage in messageType.NestedType)
        {
            CollectMessageTypeReferences(nestedMessage);
        }
    }

    private void GenerateImports()
    {
        var imports = _typeResolver.GetRequiredImports(_referencedExternalTypes);
        if (imports.Count == 0)
            return;

        // 按proto文件分组，每个文件导入多个类型
        var importsByFile = imports.GroupBy(x => x.protoFile)
                                   .ToDictionary(g => g.Key, g => g.Select(x => x.simpleName).Distinct().ToList());

        // 存储导入别名映射
        var importAliases = new Dictionary<string, string>();

        foreach (var (protoFile, typeNames) in importsByFile)
        {
            // 计算导入路径：将.proto扩展名替换为.mjs，并确保相对路径正确
            string importPath = GetImportPath(protoFile);
            string alias = GenerateImportAlias(protoFile);

            // 确保别名唯一
            int counter = 1;
            string originalAlias = alias;
            while (importAliases.ContainsValue(alias))
            {
                alias = originalAlias + counter;
                counter++;
            }

            importAliases[protoFile] = alias;

            // 生成import * as语句
            string importStatement = $"import * as {alias} from '{importPath}';";
            _sb.AppendLine(importStatement);
        }

        _sb.AppendLine();

        // 存储别名映射供后续使用
        _importAliases = importAliases;
    }

    private string GetImportPath(string protoFilePath)
    {
        // 将.proto扩展名替换为.mjs
        string mjsPath = System.IO.Path.ChangeExtension(protoFilePath, ".mjs");

        // 确保使用正斜杠
        mjsPath = mjsPath.Replace('\\', '/');

        // 添加"./"前缀，除非已经是相对路径
        if (!mjsPath.StartsWith("./") && !mjsPath.StartsWith("../"))
        {
            mjsPath = "./" + mjsPath;
        }

        return mjsPath;
    }

    private string GenerateImportAlias(string protoFilePath)
    {
        // 移除扩展名
        string fileName = System.IO.Path.GetFileNameWithoutExtension(protoFilePath);
        // 移除前导"./"或"../"
        string path = protoFilePath.Replace('\\', '/');
        if (path.StartsWith("./"))
            path = path.Substring(2);
        else if (path.StartsWith("../"))
            path = path.Substring(3);

        // 移除扩展名
        path = System.IO.Path.ChangeExtension(path, null);

        // 分割路径部分
        var parts = path.Split('/');

        // 将每个部分转换为帕斯卡命名（首字母大写）
        for (int i = 0; i < parts.Length; i++)
        {
            if (string.IsNullOrEmpty(parts[i]))
                continue;

            // 移除非法字符，只保留字母数字
            string cleaned = Regex.Replace(parts[i], @"[^a-zA-Z0-9_]", "_");
            if (cleaned.Length == 0)
                cleaned = "Part";

            // 确保首字母大写
            if (char.IsLower(cleaned[0]))
            {
                cleaned = char.ToUpper(cleaned[0]) + cleaned.Substring(1);
            }

            parts[i] = cleaned;
        }

        // 合并所有部分
        string alias = string.Join("", parts.Where(p => !string.IsNullOrEmpty(p)));

        // 如果alias为空或以下划线开头，添加前缀
        if (string.IsNullOrEmpty(alias) || alias[0] == '_')
            alias = "Import" + alias;

        // 确保alias以字母开头
        if (alias.Length > 0 && !char.IsLetter(alias[0]))
            alias = "Import" + alias;

        return "__" + alias;
    }

    private string? TransformTypeName(string typeName, FileDescriptorProto protoFile)
    {
        // 只有当前文件匹配时才处理
        if (protoFile != _protoFile)
            return null;

        var externalInfo = _typeResolver.GetExternalTypeInfo(typeName);
        if (externalInfo.HasValue && externalInfo.Value.protoFile != null && _importAliases.TryGetValue(externalInfo.Value.protoFile, out string? alias))
        {
            // 外部类型，使用别名
            return $"{alias}.{externalInfo.Value.simpleName}";
        }

        // 返回null让TypeHelper使用默认逻辑
        return null;
    }

    private void RecordTypeReference(string typeName)
    {
        if (!string.IsNullOrEmpty(typeName))
        {
            _referencedExternalTypes.Add(typeName);
        }
    }

    private void GenerateEnum(EnumDescriptorProto enumType)
    {
        _sb.AppendLine($"// Enum: {enumType.Name}");
        _sb.AppendLine($"export const {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"    {value.Name}: {value.Number},");
        }

        _sb.AppendLine("};");
        _sb.AppendLine();
    }

    private void GenerateMessage(DescriptorProto messageType, string indent, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";
        var isTopLevel = string.IsNullOrEmpty(indent);

        if (!isTopLevel)
        {
            // 嵌套消息不应该通过这个方法生成
            return;
        }

        // 首先为所有嵌套消息生成独立类定义
        Dictionary<DescriptorProto, string> nestedIndependentClassNames = new Dictionary<DescriptorProto, string>();
        foreach (var nestedMessage in messageType.NestedType)
        {
            string independentClassName = GenerateNestedMessageClass(nestedMessage, fullName);
            nestedIndependentClassNames[nestedMessage] = independentClassName;
        }

        // 生成顶级导出类
        _sb.AppendLine($"{indent}// Message: {className}");
        _sb.AppendLine($"{indent}export class {className} {{");

        // 静态描述符
        _sb.AppendLine($"{indent}    static __descriptor = {{");
        _sb.AppendLine($"{indent}        name: \"{className}\",");
        _sb.AppendLine($"{indent}        fullName: \"{fullName}\",");
        if (!string.IsNullOrEmpty(parentFullName))
        {
            _sb.AppendLine($"{indent}        package: \"{parentFullName}\",");
        }
        // 字段描述符
        _sb.Append($"{indent}        fields: [");
        if (messageType.Field.Count > 0)
        {
            _sb.AppendLine();
            for (int i = 0; i < messageType.Field.Count; i++)
            {
                var field = messageType.Field[i];
                _sb.Append($"{indent}            {{");
                _sb.Append($"name: \"{field.Name}\", ");
                _sb.Append($"number: {field.Number}, ");
                _sb.Append($"type: \"{field.Type.ToString()}\", ");
                if (!string.IsNullOrEmpty(field.TypeName))
                {
                    _sb.Append($"typeName: \"{field.TypeName}\", ");
                }
                _sb.Append($"label: \"{field.Label.ToString()}\"");
                _sb.Append("}");
                if (i < messageType.Field.Count - 1)
                {
                    _sb.AppendLine(",");
                }
                else
                {
                    _sb.AppendLine();
                }
            }
            _sb.Append($"{indent}        ]");
        }
        else
        {
            _sb.Append("]");
        }
        _sb.AppendLine();
        _sb.AppendLine($"{indent}    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, indent + "    ", className);
        }

        // 添加嵌套消息的静态引用
        foreach (var nestedMessage in messageType.NestedType)
        {
            string independentClassName = nestedIndependentClassNames[nestedMessage];
            _sb.AppendLine($"{indent}    static {nestedMessage.Name} = {independentClassName};");
        }

        // 生成嵌套枚举
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, indent + "    ");
        }

        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();
    }

    private string GenerateNestedMessageClass(DescriptorProto messageType, string parentFullName)
    {
        var className = messageType.Name;
        var fullName = string.IsNullOrEmpty(parentFullName) ? className : $"{parentFullName}.{className}";

        // 如果已经生成，则返回独立类名
        if (_generatedNestedClasses.Contains(fullName))
        {
            return TypeHelper.GetIndependentClassName(fullName, _protoFile);
        }

        _generatedNestedClasses.Add(fullName);

        // 生成独立类定义
        string independentClassName = TypeHelper.GetIndependentClassName(fullName, _protoFile);
        _sb.AppendLine($"class {independentClassName} {{");

        // 静态描述符
        _sb.AppendLine($"    static __descriptor = {{");
        _sb.AppendLine($"        name: \"{className}\",");
        _sb.AppendLine($"        fullName: \"{fullName}\",");
        // 字段描述符
        _sb.Append($"        fields: [");
        if (messageType.Field.Count > 0)
        {
            _sb.AppendLine();
            for (int i = 0; i < messageType.Field.Count; i++)
            {
                var field = messageType.Field[i];
                _sb.Append($"            {{");
                _sb.Append($"name: \"{field.Name}\", ");
                _sb.Append($"number: {field.Number}, ");
                _sb.Append($"type: \"{field.Type.ToString().Replace("Type.", "")}\", ");
                if (!string.IsNullOrEmpty(field.TypeName))
                {
                    _sb.Append($"typeName: \"{field.TypeName}\", ");
                }
                _sb.Append($"label: \"{field.Label.ToString().Replace("Label.", "")}\"");
                _sb.Append("}");
                if (i < messageType.Field.Count - 1)
                {
                    _sb.AppendLine(",");
                }
                else
                {
                    _sb.AppendLine();
                }
            }
            _sb.Append($"        ]");
        }
        else
        {
            _sb.Append("]");
        }
        _sb.AppendLine();
        _sb.AppendLine($"    }}");
        _sb.AppendLine();

        // 生成字段的getter/setter方法
        foreach (var field in messageType.Field)
        {
            GenerateFieldMethods(field, "    ", independentClassName);
        }

        // 递归生成嵌套消息的独立类定义，并在当前类中添加静态引用
        foreach (var nestedMessage in messageType.NestedType)
        {
            string nestedIndependentClassName = GenerateNestedMessageClass(nestedMessage, fullName);
            // 在当前类中添加静态引用
            _sb.AppendLine($"    static {nestedMessage.Name} = {nestedIndependentClassName};");
        }

        // 生成嵌套枚举（保持不变）
        foreach (var nestedEnum in messageType.EnumType)
        {
            _sb.AppendLine();
            GenerateNestedEnum(nestedEnum, "    ");
        }

        _sb.AppendLine($"}}");
        _sb.AppendLine();

        return independentClassName;
    }

    private void GenerateNestedEnum(EnumDescriptorProto enumType, string indent)
    {
        _sb.AppendLine($"{indent}// Nested enum: {enumType.Name}");
        _sb.AppendLine($"{indent}static {enumType.Name} = {{");

        foreach (var value in enumType.Value)
        {
            _sb.AppendLine($"{indent}    {value.Name}: {value.Number},");
        }

        _sb.AppendLine($"{indent}}};");
    }

    private void GenerateFieldMethods(FieldDescriptorProto field, string indent, string className)
    {
        var fieldName = field.Name;
        var camelCaseName = fieldName.SnakeToCamelCase();
        var pascalCaseName = fieldName.SnakeToPascalCase();

        // 检查是否是oneof字段
        bool isOneofField = field.HasOneofIndex && field.OneofIndex >= 0;

        if (isOneofField)
        {
            _sb.AppendLine($"{indent}// Oneof field (index: {field.OneofIndex})");
        }

        // 记录外部类型引用
        if (field.Type == FieldDescriptorProto.Types.Type.Message ||
            field.Type == FieldDescriptorProto.Types.Type.Enum)
        {
            RecordTypeReference(field.TypeName);
        }

        // 字段类型映射
        var jsType = TypeHelper.GetJsType(field, _protoFile);

        // Getter方法
        _sb.AppendLine($"{indent}/** ");
        _sb.AppendLine($"{indent} * @return {{{jsType}}} ");
        _sb.AppendLine($"{indent} */");
        _sb.AppendLine($"{indent}get{TypeHelper.GetMethodName(field)}() {{");
        _sb.AppendLine($"{indent}    return this.{fieldName};");
        _sb.AppendLine($"{indent}}}");
        _sb.AppendLine();

        // Setter方法（支持流式调用）
        _sb.AppendLine($"{indent}/** ");
        _sb.AppendLine($"{indent} * @param {{{jsType}}} value ");
        _sb.AppendLine($"{indent} * @return {{{className}}} ");
        _sb.AppendLine($"{indent} */");
        _sb.AppendLine($"{indent}set{TypeHelper.GetMethodName(field)}(value) {{");
        _sb.AppendLine($"{indent}    this.{fieldName} = value;");
        _sb.AppendLine($"{indent}    return this;");
        _sb.AppendLine($"{indent}}}");

        // 如果不是最后一个字段，添加空行
        _sb.AppendLine();
    }
}